*nvlime.txt*  A Common Lisp dev environment for Neovim         *nvlime*

======================================================================
CONTENTS                                              *nvlime-contents*

    1. Introduction ................................ |nvlime-intro|
    2. Concepts ................................. |nvlime-concepts|
    3. Usage ....................................... |nvlime-usage|
        3.1 Starting Up ......................... |nvlime-start-up|
        3.2 Completions ...................... |nvlime-completions|
        3.3 Automatic Indentation ............ |nvlime-auto-indent|
        3.4 REPL .................................... |nvlime-repl|
        3.5 Debugger ............................ |nvlime-debugger|
        3.6 Inspector .......................... |nvlime-inspector|
        3.7 Cross References ........................ |nvlime-xref|
        3.8 Compiler Messages ............... |nvlime-compiler-msg|
        3.9 Managing Threads ................. |nvlime-thread-list|
        3.10 Remote Servers ................ |nvlime-remote-server|
        3.11 Input Windows ................. |nvlime-input-windows|
        3.12 Trace Dialog ................... |nvlime-trace-dialog|
        3.13 Multiple REPLs ........................ |nvlime-mrepl|
    4. Configuration .............................. |nvlime-config|
    5. Key Mappings ............................. |nvlime-mappings|
    6. Key Actions ............................... |nvlime-actions|
        6.1 Global Actions ................ |nvlime-actions-global|
        6.2 CL Source File Actions ........ |nvlime-actions-source|
        6.3 Input Window Actions ........... |nvlime-actions-input|
        6.4 REPL Actions .................... |nvlime-actions-repl|
        6.5 Debugger Actions ............ |nvlime-actions-debugger|
        6.6 Apropos Actions .............  |nvlime-actions-apropos|
        6.7 Inspector Actions .......... |nvlime-actions-inspector|
        6.8 Compiler Notes Actions ......... |nvlime-actions-notes|
        6.9 Server Window Actions ......... |nvlime-actions-server|
        6.10 Thread List Actions ......... |nvlime-actions-threads|
        6.11 Trace Dialog Actions ... |nvlime-actions-trace-dialog|
        6.12 XRef List Actions .............. |nvlime-actions-xref|
        6.13 MREPL Window Actions .......... |nvlime-actions-mrepl|
    7. API ..................................... |nvlime-api-intro|
    8. License ................................... |nvlime-license|
    9. Bugs ......................................... |nvlime-bugs|
    10. Contributing ............................. |nvlime-contrib|

======================================================================
1. Introduction                                          *nvlime-intro*

Nvlime is a Common Lisp dev environment for Neovim, similar to SLIME
for Emacs.

It provides REPL integration, as well as omni-completions, cross
reference utilities, a nice inspector, debugger support, and many
other great facilities to aid you in your glorious Common Lisp hacking
quest.

These Common Lisp implementations are supported:

    Implementation  Version  Notes
    ---------------------------------------------------------------
    ABCL            1.4.0    Supported by the nvlime-patched backend
    Allegro CL      10.0     Tested with the Express Edition
    CLISP           2.49+    No multithreading support
    ECL             16.1.3   No debugger support
    CCL             1.11
    SBCL            1.3.13
    LispWorks       6.1      Tested with the Personal Edition

======================================================================
2. Concepts                                           *nvlime-concepts*

Connection                                          *nvlime-connection*
    A connection between Neovim and a Nvlime server. Most of Nvlime's
    functionalities need an active connection to work. Each Neovim
    process can have multiple connections.
    See `g:nvlime_mappings.lisp.normal.connection` for available
    operations regarding connections.

The Current Connection                      *nvlime-current-connection*
    A connection (|nvlime-connection|) that's bound to the current
    Neovim buffer. All Nvlime operations in the current buffer will use
    this connection. Nvlime will try to choose and remember an open
    connection for a buffer automatically, but it's also possible to
    select one via `g:nvlime_mappings.lisp.normal.connection.switch`.

The Current Package                            *nvlime-current-package*
    A Common Lisp package that's bound to the current Neovim buffer. All
    Nvlime operations that concern about the Common Lisp package, such
    as omni-completions, will use this value. Nvlime will try to figure
    out the current package automatically, but it's also possible to
    specify a package via `g:nvlime_mappings.lisp.normal.set_package`.

======================================================================
3. Usage                                                 *nvlime-usage*

----------------------------------------------------------------------
3.1 Starting Up                                       *nvlime-start-up*

If you have sbcl in your $PATH, Nvlime can start a server for you:

    1. Set up Quicklisp properly.
    2. Start editing a Common Lisp source file, and use
       `g:nvlime_mappings.lisp.normal.server.new` to run a server.
    3. Wait for the server. Nvlime will automatically connect to it
       when it's ready, and become fully operational.

Note: If it's your first time running the server, Nvlime will try to
      install it's dependencies via Quicklisp. This may take some
      time.

See |nvlime-actions-source| for more operations on Nvlime servers,
and |nvlime-actions-server| for operations available in the server
output buffer. See |nvlime-mappings| for all available Nvlime
operations.

When you need to use some other Common Lisp implementation, run an
instance of sbcl in arbitrary locations, or pass special arguments to
the server, use the |g:nvlime_config.implementation| option.

                                             *nvlime-start-up-manually*
You may also start the server manually:

    1. Set up Quicklisp properly.
    2. Run the server:

        sbcl --load <nvlime repo>/lisp/start-nvlime.lisp

    3. Start editing a Common Lisp source file, and use
       `g:nvlime_mappings.lisp.normal.connection.new` to
       create a new connection.
    4. Nvlime shoud now be fully operational.

                                     *nvlime-start-up-in-running-image*
If you have a running Common Lisp image, and want to start the server
in it:

    1. Make sure the Quicklisp client is loaded (by loading the
       corresponding "setup.lisp" file, for example).
    2. Make sure the "<nvlime repo>/lisp/" directory (or a symlink
       pointing to it) is in your "<quicklisp>/local-projects/"
       directory.
    3. Evaluate "(ql:quickload :nvlime)" to load the bootstrapping
       code.
    4. Evaluate "(nvlime:main)" to start the server, or something like

        (nvlime:main :interface #(127 0 0 1)
                    :port 7002
                    :backend :nvlime-usocket)

       to specify the backend and the address to bind to.

See |nvlime-server-options| for a full list of parameters you can pass
to the NVLIME:MAIN function.

                                               *nvlime-server-backends*
Note that Nvlime's server has three backends:

    :nvlime-usocket          Suitable for environments that support
                            multithreading. Depends on usocket.

    :nvlime-sbcl             Suitable for SBCL without multithreading.
                            Only works on Linux/Unix systems. Depends
                            on SBCL-specific APIs.

    :nvlime-patched          Suitable for other environments. Patches
                            Swank to support the Nvlime protocol. Has
                            the least dependencies.

The bootstrapping code takes special measures to automatically detect
and load the correct backend. Usually you can just omit the :BACKEND
argument of the NVLIME:MAIN function.

                                    *nvlime-include-server-in-cl-image*
To include the Nvlime server in your Common Lisp image, just load the
NVLIME system and at least one backend that works for your. For
example, a typical SBCL image can be generated by:

    (ql:quickload :nvlime)
    (ql:quickload :nvlime-usocket)
    (sb-ext:save-lisp-and-die ...)

To start the server, call "(nvlime:main :backend :nvlime-usocket)" in
your running image.

                                                  *nvlime-slime-secret*
When connecting to a server, Nvlime will try to use the file
"$HOME/.slime-secret" to authenticate the connection. Just put one
single line containing a secret phrase in this file, make sure it's
readable, and Nvlime will automatically enable authentication for all
connections.

                                                *nvlime-server-options*
The server entry point (i.e. the NVLIME:MAIN function) accepts some
keyword arguments to allow the caller to fine-tune server behavior:

    :backend
        One of the backends listed in |nvlime-server-backends|, or NIL
        to let the server choose a backend automatically. Default: NIL

    :interface
        A vector specifying the IP address of the interface to bind
        to. Default: #(127 0 0 1)

    :port
        An integer specifying the TCP port number to listen on. A
        value of zero tells the server to choose an arbitrary port.
        Default: 0

    :port-file
        If this argument is not NIL, the server will write the port
        number on which it's listening in the specified file, once the
        server is fully operational. Default: NIL

    :start-swank
        Whether to start a Swank server or not. Usually the Nvlime
        server will start a Swank server automatically, and relay all
        requests to it. If you have a Swank server that's already
        running, and you want to use that instead, pass NIL to this
        argument, and point :swank-interface and :swank-port to the
        existing Swank server. Default: T

    :swank-interface
        When the :start-swank argument is T, this argument specifies
        the interface that the new Swank server binds to. Otherwise
        this should be the interface for a running Swank server.
        Default: #(127 0 0 1)

    :swank-port
        When the :start-swank argument is T, this argument specifies
        the port that the new Swank server listens on. Otherwise this
        should be the port for a running Swank server. Default: 0

    :dont-close
        Do not shutdown the server after the first connection. Pass
        NIL to allow one client only. Default: T

----------------------------------------------------------------------
3.2 Completions                                    *nvlime-completions*

----------------------------------------------------------------------
3.3 Automatic Indentation                          *nvlime-auto-indent*

The auto indent feature will just work as you type. It supports both
space and tab characters. Which to use is determined by the
|expandtab| Neovim option.

To adjust mis-indented lines, press <Tab> at the start of those lines
in insert mode, or use |=| command.

Nvlime has a set of indent rules that are similar to the ones SLIME
used. Multi-line expressions are generally indented by the width of
two space characters, regardless of the value of |shiftwidth|. Macros
and special operators with "&BODY" arguments are treated specially, in
that all the arguments before "&BODY" will be indented one more level.
For example, MULTIPLE-VALUE-BIND has two arguments before "&BODY", so
a call to it will be indented this way:

    (multiple-value-bind
        (val exist-p)
        (gethash "key" hash-table)
      (do-something)
      (do-other-thing))

You can control how an operator and its arguments are indented using
|g:nvlime_config.indent_keywords|.

----------------------------------------------------------------------
3.4 REPL                                                  *nvlime-repl*

The REPL integration is different from other Lisp environments, in
that Nvlime's REPL buffer is read-only. One can send expressions to the
REPL from any lisp source buffer using normal mode commands such as
`g:nvlime_mappings.lisp.normal.repl.send_atom_expr`, instead of typing
the input directly in the REPL buffer.

Note: It's a design decision to make the REPL buffer read-only, since
      emulating a command line in Neovim buffers is often complicated
      and buggy.

When the REPL needs user input, e.g. (read) or (read-line) is being
evaluated, a dedicated window for string input would pop up. Write
the input inside this buffer, and hit <CR> in normal mode, then the
REPL would receive your text. The input buffer is a generic mechanism
for the commands that need user input. See |nvlime-input-windows|.

                                              *nvlime-interaction-mode*
There's an interaction mode to make sending things to the REPL easier.
It's enabled via `g:nvlime_mappings.lisp.normal.interaction_mode` in
Common Lisp source buffers. In this mode, simply pressing <CR> will
send the s-expression under the cursor.

One can inspect the evaluation results right from the REPL buffer. See
|nvlime-actions-repl| for avaialble operations.

----------------------------------------------------------------------
3.5 Debugger                                          *nvlime-debugger*

The debugger works just like SLDB in SLIME. It pops up a buffer when a
condition is signalled. The buffer shows a list of restarts and a
backtrace. One can press <CR> on a restart to select it.

The debugger can also do single-stepping, examine the local variables,
restart frames, evaluate expressions in frames, etc., provided the
Common Lisp implementation Nvlime server is running on supports these.
For more available operations in the debugger buffer, see
|nvlime-actions-debugger|.

Note: Some debugger features are not supported by some Common Lisp
      implementations. These unsupported operations will most likely
      result in an error message.

----------------------------------------------------------------------
3.6 Inspector                                        *nvlime-inspector*

The inspector can be used to examine the slot values of instances,
the members of structs, the items of hashtables, etc. It's a very
handy tool in many circumstances.

There're multiple ways to invoke the inspector, but the most convenient
one is using `g:nvlime_mappings.lisp.normal.inspect.atom_expr`
on an expression.

The content shown in the inspector buffer usually contains multiple
interactable fields and buttons. Pressing <Tab> will move the cursor
between theses fields/buttons, and <CR> interact with them. If the
interaction needs extra user input, an input buffer would pop up. See
|nvlime-input-windows|.

For more available operations in the inspector window, see
|nvlime-actions-inspector|.

----------------------------------------------------------------------
3.7 Cross References                                      *nvlime-xref*

The cross references (a.k.a xref) buffer shows where a symbol is
referenced. For example, use
`g:nvlime_mappings.lisp.normal.xref.function.callers` on a function
name to see where the function is called. Pressing <CR> on an entry
inside the xref buffer will take you directly to the reference location.

For more xref types and key mappings, see |nvlime-actions-source|.
For all available operations in the xref window, see
|nvlime-actions-xref|.

----------------------------------------------------------------------
3.8 Compiler Messages                             *nvlime-compiler-msg*

When issuing compilation commands specified in
|nvlime-actions-source|, any message (warnings and errors etc.)
emitted by the compiler would pop up in a dedicated window. Just
select a message by pressing <CR>, and Nvlime will take you to the
referenced source location.

For all available operations in the compiler message window, see
|nvlime-actions-notes|.

----------------------------------------------------------------------
3.9 Managing Threads                               *nvlime-thread-list*

For CL implementations that support threads, there's a window that
shows all running threads. Use
`g:nvlime_mappings.lisp.normal.show_threads` to show it.
While in the thread list, you can perform tasks such as killing a
thread, or activating the debugger in a thread. See
|nvlime-actions-threads| for a full list of available operations.

----------------------------------------------------------------------
3.10 Remote Servers                              *nvlime-remote-server*

Nvlime can connect to a server running on a remote machine. The most
secure way is to use SSH tunnels. Say we want to run a Nvlime server on
Mars:

    ssh watney@mars-hab \
        -L 7002:localhost:7002 \
        sbcl --load <nvlime repo>/lisp/start-nvlime.lisp

This command will also set up local port forwarding, so that we can
connect to the server right here on Earth. Then, in Neovim, call
nvlime#plugin#ConnectREPL():

    :call nvlime#plugin#ConnectREPL("127.0.0.1", 7002, "sftp://watney@mars-hab/", 5000)

The third argument is an SFTP URL to tell Nvlime that all filenames
returned by the server resides in the remote machine, and should be
opened through SFTP. The last argument is the time to wait for the
connection to be made, in milliseconds (Let's just pretend we can
connect to Mars in 5 seconds). When running through a network with
high latency, you may want to raise this value.

Note: When connecting to a remote server, relative file paths may
      cause problems. Please make sure the remote Nvlime server runs in
      the directory that your paths are relative to. Nvlime always
      tries to use absolute paths.

----------------------------------------------------------------------
3.11 Input Windows                               *nvlime-input-windows*

When Nvlime needs user input, a dedicated input window would pop up.
One can use it to compose any text snippet in it, and then press <CR>
in insert or normal mode to submit the snippet to Nvlime.

If the operation that brought up the input buffer can be cancelled,
submitting an empty snippet would usually cancel that operation.

Submitted text snippets are remembered as a linear input history. You
can move to the previous/next item in history with <C-p>/<C-n>. See
|nvlime-actions-input|.

----------------------------------------------------------------------
3.12 Trace Dialog                                 *nvlime-trace-dialog*

Note: This feature needs the SWANK-TRACE-DIALOG contrib module. See
      |g:nvlime_config.contribs| and |nvlime#plugin#SwankRequire()|.

Nvlime can trace functions and show the results in a dedicated window
for you. It's called the trace dialog, named after the similar
component in SLIME. One can use
`g:nvlime_mappings.lisp.normal.trace.show` to have it open.

The trace dialog will show two kinds of info: a list of traced
functions, and the trace results. It also contains multiple
interactable fields and buttons. You can navigate through these
fields/buttons by pressing <Tab>, and interact with them using <CR>.

Nested trace entries are folded by default. Use standard
|fold-commands| to handle the |folds|.

For more available operations for the trace dialog, see
|nvlime-actions-trace-dialog|, and |nvlime-actions-source|.

----------------------------------------------------------------------
3.13 Multiple REPLs                                      *nvlime-mrepl*

Note: This feature needs the SWANK-MREPL contrib module. See
      |g:nvlime_config.contribs| and |nvlime#plugin#SwankRequire()|.
      And it works best on CL implementations with multithreading
      support.

Nvlime usually creates a single REPL upon connection. If this REPL were
blocked by a time-consuming operation, the server may seem
unresponsive. The multiple REPL support may come in handy in this
case.

One can call |nvlime#plugin#CreateMREPL()| to spawn a new REPL, and
open an "mrepl" command line buffer automatically. Just enter |Insert|
mode and use it as you may use any other REPL prompts. But note that
the command line is somewhat fragile, in that it is implemented by
simply extracting the text between the last prompt string and EOF.
Modifying text outside this range may cause unexpected bahavior.

See |nvlime-actions-mrepl| for all available operations in the MREPL
windows.

======================================================================
4. Configuration                                        *nvlime-config*

Nvlime configuration is done using two dictionaries `g:nvlime_config`
and `g:nvlime_mappings` (which is described in the next section).
Currently some options which require |Funcref|s can be configured
only with vimscript. Lua config:
>lua
    vim.g.nvlime_config = {
        leader = "<LocalLeader>",
        implementation = "sbcl",
        address = {
            host = "127.0.0.1",
            port = 7002
        },
        connect_timeout = -1,
        compiler_policy = nil,
        -- full table of indent keywords is provided in the
        -- options description section
        indent_keywords = { defun = 2, ... },
        input_history_limit = 100,
        -- full list of contribs is provided in the
        -- options description section
        contribs = ["SWANK-ARGLISTS", ...],
        -- configured with vimscript
        user_contrib_initializers = nil,
        autodoc = {
            enabled = false,
            max_level = 5,
            max_lines = 50
        },
        main_window = {
            position = "right",
            size = ""
        },
        floating_window = {
            border = "single",
            scroll_step = 3
        },
        cmp = { enabled = false },
        arglist = { enabled = true }
    }
<

leader                                         *g:nvlime_config.leader*
    `string`
    Default: "<LocalLeader>"
    Sets the leader key used in Nvlime key mappings. This supersedes
    |maplocalleader|. Please use key notations for special keys, as
    described in |key-notation|. For example, setting this variable
    to "<Space>" would instruct Nvlime to use the space key as the
    leader. Also see |nvlime-mappings|.

implementation                         *g:nvlime_config.implementation*
    `string`
    Default: "sbcl"
    Sets the CL implementation to use when starting a server via
    `g:nvlime_mappings.lisp.normal.server.new`. This option has no
    effect when connecting to an existing server via
    `g:nvlime_mappings.lisp.normal.connection.new`.

    You can define a function named
    "NvlimeBuildServerCommandFor_<impl>" to build a command line for
    your implementation. For maximum compatibility, this function
    should return a list containing all the command line components.
    See |jobstart()| for detailed explanation on command lines.

    For example, to use a custom SBCL and a custom Quicklisp setup,
    add these to your |init.vim|:

        let g:nvlime_cl_impl = "my_sbcl"
        function! NvlimeBuildServerCommandFor_my_sbcl(nvlime_loader, nvlime_eval)
            return ["/path/to/my/custom/sbcl",
                        \ "--load", "/path/to/my/custom/quicklisp/setup.lisp",
                        \ "--load", a:nvlime_loader,
                        \ "--eval", a:nvlime_eval]
        endfunction

    Or, if you prefer using Roswell to manage your implementations:

        let g:nvlime_cl_impl = "ros"
        function! NvlimeBuildServerCommandFor_ros(nvlime_loader, nvlime_eval)
            return ["ros", "run",
                        \ "--load", a:nvlime_loader,
                        \ "--eval", a:nvlime_eval]
        endfunction

    Then restart Neovim and call nvlime#server#BuildServerCommand() to see
    whether the new command is OK:

        :echo nvlime#server#BuildServerCommand()

    The command returned by nvlime#server#BuildServerCommand() will be
    executed to start a Nvlime server when the
    `g:nvlime_mappings.lisp.normal.server.new` command is invoked.

    Nvlime has these builder functions predefined:

        " For SBCL, the default
        nvlime#server#BuildServerCommandFor_sbcl()
        " For Clozure CL, set g:nvlime_cl_impl to "ccl"
        nvlime#server#BuildServerCommandFor_ccl()

    If you use other implementations, such as clisp and abcl, or need
    to pass special arguments to the server, you'll need to define the
    builder functions.

Note: If you use symlinks on Windows systems to point to Nvlime, it may
      fail to locate the server entry point automatically. In this
      case you'll have to define a command builder function and
      overwrite "nvlime_loader" with the absolute path of
      "load-nvlime.lisp":

          function! NvlimeBuildServerCommandFor_xxx(nvlime_loader, nvlime_eval)
              return ["sbcl",
                          \ "--load", "c:\\path\\to\\nvlime\\lisp\\load-nvlime.lisp",
                          \ "--eval", a:nvlime_eval]
          endfunction

address                                        *g:nvlime_config.address*
    `dictionary`
    Default: { host = "127.0.0.1", port = 7002 }
    Sets the default address of the Nvlime server. This address will
    be used as the default host and port values in the
    `g:nvlime_mappings.lisp.normal.connection.new` command.

connect_timeout                        *g:nvlime_config.connect_timeout*
    `integer`
    Default: -1
    An integer specifying the time to wait when connecting to the
    server, in milliseconds. If set to -1, Nvlime would try to
    use the default timeout values on different platforms.

compiler_policy                        *g:nvlime_config.compiler_policy*
    `dictionary`
    Default: nil
    Sets the compiler policy. Setting this variable would affect
    the subsequent compiling operations. For example, a value of
    { DEBUG = 3, SPEED = 0 } means no optimization in runtime speed,
    and maximum debug info. Note that the keys are case-sensitive.
    Please use only uppercase.

indent_keywords                        *g:nvlime_config.indent_keywords*
    `dictionary`
    Default: Check `:echo g:nvlime_options.indent_keywords`
    Specifies indent rules for operators. The keys should be operator
    names in lowercase, and the values should be the number of
    arguments before "&BODY", or other numbers that you prefer. Also
    see |nvlime-auto-indent|. For example,

        vim.g.nvlime_config.indent_keywords = { dummy-op = 1 }

    Will cause a DUMMY-OP expression to be indented this way:

        (dummy-op
            expr1
          expr2
          expr3
          ...)

    And

        vim.g.nvlime_config.indent_keywords = { dummy-op = 2 }

    Will cause the same expression to be indented this way:

        (dummy-op
            expr1
            expr2
          expr3
          ...)

input_history_limit                *g:nvlime_config.input_history_limit*
    `integer`
    Default: 100
    How many input history items to store. A non-positive
    value disables input history. See |nvlime-input-windows|.

contribs                                      *g:nvlime_config.contribs*
    `list`
    Default: ["SWANK-ASDF", "SWANK-PACKAGE-FU",
              "SWANK-PRESENTATIONS", "SWANK-FANCY-INSPECTOR",
              "SWANK-C-P-C", "SWANK-ARGLISTS",
              "SWANK-REPL", "SWANK-FUZZY"]
    Swank contribs to load when initializing a Nvlime connection.
    Note that the names are case-sensitive. Please use only uppercase.

    Some contrib modules will just work once they are loaded, but
    others may need specialized support on the client side. Nvlime
    elaborately supports these contribs by providing conforming client
    code:

        SWANK-ARGLISTS
            Show a fancy arglist. See |g:nvlime_enable_autodoc|.

        SWANK-FUZZY
            Enable fuzzy search in completions. See
            |nvlime-completions|.

        SWANK-MREPL
            Support for multiple REPLs. See |nvlime-mrepl|.

        SWANK-PRESENTATION-STREAMS
            Enable presentations on the standard output stream, and
            other similar streams, so that you can use
            `g:nvlime_mappings.repl.normal.yank` and similar mappings
            on printed objects.

        SWANK-PRESENTATIONS
            Turn evaluation results in the REPL into presentations,
            so that you can use `g:nvlime_mappings.repl.normal.yank`
            and similar mappings on the results.

        SWANK-REPL
            The default REPL implementation.

        SWANK-TRACE-DIALOG
            Interactively trace functions, and view the trace results.
            See |nvlime-trace-dialog|.

    Please consult the SLIME documentation for detailed descriptions
    for these modules.

    Alternatively, you can call |nvlime#plugin#SwankRequire()| to load
    contrib modules.

user_contrib_initializers   *g:nvlime_config.user_contrib_initializers*
    `dictionary`
    Default: nil
    |Funcref|s for initializing user contrib modules. The keys should
    be contrib module names (usually in uppercase). If your Swank
    contrib module needs special initialization, add an initializer
    function here. See autoload/nvlime/contrib.vim for examples.
    Can be configured only with vimscript.

autodoc                                       *g:nvlime_config.autodoc*
    `dictionary`

    enabled
        `boolean`
        Default: false
        Specifies whether to enable the autodoc feature or not.
        If enabled, the current argument will be marked in the
        arglist, when typing parentheses-enclosed expressions.

    max_level
        `integer`
        Default: 5
        A positive integer specifying how many levels of enclosing
        parentheses should Nvlime search for, when determining the
        arglist for the autodoc feature. Setting this to a smaller
        value may improve performance.

    max_lines
        `integer`
        Default: 50
        A positive integer specifying how many lines to search, when
        determining the arglist for the autodoc feature. Setting this
        to a smaller value may improve performance.

main_window                                *g:nvlime_config.main_window*
    `dictionary`

    position
        `string`
        Default: "right"
        Specifies the placement of the main windows
        (repl, sldb and compiler notes). Should be one of "top",
        "bottom", "left" or "right".

    size
        `string|integer`
        Default: ""
        Specifies the size of the main window split. For vertical
        splits size in columns and for horizontal split size in rows.
        Blank string uses neovim default split sizes.

floating_window                        *g:nvlime_config.floating_window*
    `dictionary`

    border
        `string|list`
        Default: "single"
        Specifies look of the floating windows border. Check
        |nvim_open_win()| documentation for available options.

    scroll_step
        `integer`
        Default: 3
        A positive integer specifying how for many lines to scroll
        floating windows with one scroll key press. Default: 3

enable_cmp                                         *g:nvlime_config.cmp*
    `dictionary`

    enabled
        `boolean`
        Default: false
        Specifies whether to enable `nvim-cmp` autocompletion source.

arglist                                        *g:nvlime_config.arglist*
    `dictionary`

    enabled
        `boolean`
        Default: true
        Specifies whether to enable automatic pop up of the
        arglist window.

======================================================================
5. Mappings                                           *nvlime-mappings*

Most normal mode and visual mode mappings in Nvlime starts with
|<LocalLeader>|, which defaults to the backslash "\". If you feel
uncomfortable reaching out for the backslash key, you may change it by
adding this line to your |init.vim| file, to use the comma instead:

    vim.g.maplocalleader = ","

Or, if you don't want to change your |<LocalLeader>|, set
|g:nvlime_config.leader| instead:

    vim.g.nvlime_config.leader = ","

You can type "<LocalLeader>?" (without the quote marks) in most of
Nvlime buffers, including Common Lisp source files, to see a quick
reference for the exact mappings defined for those windows.

The mappings configured with `g:nvlime_mappings` dictionary. Where
key is some predefined name for an action and value is a string
representing a keymap. Value could be an empty string `""` to
completely disable this action, could be some keymap (as example
"<C-p>") or it could be a list of keymaps all of which would be
mapped to this action (as example {"<Space>", "<LocalLeader>cc"})
is provided below and the description for each `action` in the next
section.
>lua
    vim.g.nvlime_mappings = {
        global = {
            normal = {
                close_current_window = "q",
                keymaps_help = {"<F1>", "<LocalLeader>?"},
                close_nvlime_windows = "<LocalLeader>ww",
                close_floating_window = "<Esc>",
                scroll_up = "<C-p>",
                scroll_down = "<C-n>",
                split_left = "<C-w>h",
                split_right = "<C-w>l",
                split_above = "<C-w>k",
                split_below = "<C-w>j"
            }
        },
        lisp = {
            normal = {
                interaction_mode = "<LocalLeader><CR>",
                load_file = "<LocalLeader>l",
                disassemble = {
                    expr = "<LocalLeader>aa",
                    symbol = "<LocalLeader>as",
                },
                set_package = "<LocalLeader>p",
                set_breakpoint = "<LocalLeader>b",
                show_threads = "<LocalLeader>T",
                connection = {
                    new = "<LocalLeader>cc",
                    switch = "<LocalLeader>cs",
                    rename = "<LocalLeader>cR",
                    close = "<LocalLeader>cd"
                },
                server = {
                    new = "<LocalLeader>rr",
                    show = "<LocalLeader>rv",
                    show_selected = "<LocalLeader>rV",
                    stop = "<LocalLeader>rs",
                    stop_selected = "<LocalLeader>rS",
                    rename = "<LocalLeader>rR",
                    restart = "<LocalLeader>rt"
                },
                repl = {
                    show = "<LocalLeader>so",
                    clear = "<LocalLeader>sC",
                    send_atom_expr = "<LocalLeader>ss",
                    send_atom = "<LocalLeader>sa",
                    send_expr = "<LocalLeader>se",
                    send_toplevel_expr = "<LocalLeader>st",
                    prompt = "<LocalLeader>si"
                },
                macro = {
                    expand = "<LocalLeader>mm",
                    expand_once = "<LocalLeader>mo",
                    expand_all = "<LocalLeader>ma"
                },
                compile = {
                    expr = "<LocalLeader>ce",
                    toplevel_expr = "<LocalLeader>ct",
                    file = "<LocalLeader>cf"
                },
                xref = {
                    function = {
                        callers = "<LocalLeader>xc",
                        callees = "<LocalLeader>xC"
                    },
                    symbol = {
                        references = "<LocalLeader>xr",
                        bindings = "<LocalLeader>xb",
                        definition = "<LocalLeader>xd",
                        set_locations = "<LocalLeader>xs"
                    },
                    macro = { callers = "<LocalLeader>xe" },
                    class = { methods = "<LocalLeader>xm" },
                    prompt = "<LocalLeader>xi"
                },
                describe = {
                    operator = "<LocalLeader>do",
                    atom = "<LocalLeader>da",
                    prompt = "<LocalLeader>di"
                },
                apropos = {prompt = "<LocalLeader>ds"},
                arglist = {show = "<LocalLeader>dr"},
                documentation = {
                    operator = "<LocalLeader>ddo",
                    atom = ["K" "<LocalLeader>dda"],
                    prompt = "<LocalLeader>ddi"
                },
                inspect = {
                    atom_expr = "<LocalLeader>ii",
                    atom = "<LocalLeader>ia",
                    expr = "<LocalLeader>ie",
                    toplevel_expr = "<LocalLeader>it",
                    symbol = "<LocalLeader>is",
                    prompt = "<LocalLeader>in"
                },
                trace = {
                    show = "<LocalLeader>td",
                    toggle = "<LocalLeader>tt",
                    prompt = "<LocalLeader>ti"
                },
                undefine = {
                    function = "<LocalLeader>uf",
                    symbol = "<LocalLeader>us",
                    prompt = "<LocalLeader>ui"
                }
            },
            insert = {
                space_arglist = "<Space>",
                cr_arglist = "<CR>"
            },
            visual = {
                repl = { send_selection = "<LocalLeader>s" },
                compile { selection = "<LocalLeader>c" },
                inspect { selection = "<LocalLeader>i" }
            }
        },
        input = {
            normal = { complete = "<CR>" },
            insert = {
                keymaps_help = "<F1>",
                complete = "<CR>",
                next_history = "<C-n>",
                prev_history = "<C-p>",
                leave_insert = "<Esc>"
            }
        },
        repl = {
            normal = {
                interrupt = "<C-c>",
                clear = "C",
                inspect_result = "i",
                yank_result = "y",
                next_result = { "<Tab>", "<C-n>" },
                prev_result = { "<S-Tab>", "<C-p>" }
            }
        },
        sldb = {
            normal = {
                action = "<CR>",
                details = "d",
                frame = {
                    toggle_details = "d",
                    source = "S",
                    source_split = "<C-s>",
                    source_vsplit = "<C-v>",
                    source_tab = "<C-t>",
                    restart = "r",
                    eval_expr = "e",
                    send_expr = "E",
                    disassemble = "D",
                    return_result = "R",
                    step = "s"
                },
                local_var = {
                    source "O",
                    inspect = "i"
                },
                step_over = "x",
                step_out = "o",
                abort = "a",
                continue = "c",
                inspect_condition = "C"
            }
        },
        apropos = { normal = { inspect = "i" } },
        inspector = {
            normal = {
                action = "<CR>",
                current = {
                    send = "s",
                    source = "o"
                },
                inspected = {
                    send = "S",
                    source = "O",
                    previous = "<C-o>",
                    next = "<C-i>"
                },
                next_field = { "<Tab>", "<C-n>" },
                prev_field = { "<S-Tab>", "<C-p" },
                refresh = "R"
            }
        },
        notes = {
            normal = {
                source = "<CR>",
                source_split = "<C-s>",
                source_vsplit = "<C-v>",
                source_tab = "<C-t>"
            }
        },
        server = {
            normal = {
                connect = "<LocalLeader>c",
                stop = "<LocalLeader>s"
            }
        },
        threads = {
            normal = {
                interrupt = "<C-c>",
                kill = "K",
                invoke_debugger = "D",
                refresh = "r"
            }
        },
        trace = {
            normal = {
                action = "<CR>",
                refresh = "R",
                inspect_value = "i",
                send_value = "s",
                next_field = { "<Tab>", "<C-n>" },
                prev_field = { "<S-Tab>", "<C-p" }
            }
        },
        xref = {
            normal = {
                source = "<CR>",
                source_split = "<C-s>",
                source_vsplit = "<C-v>",
                source_tab = "<C-t>"
            }
        },
        mrepl = {
            normal = {
                clear = "<LocalLeader>C",
                disconnect = "<LocalLeader>D"
            },
            insert = {
                space_arglist = "<Space>",
                cr_arglist = "<C-j>",
                submit = "<CR>",
                interrupt = "<C-c>"
            }
        },
    }
<

----------------------------------------------------------------------
6. List of Key Actions                            *nvlime-actions-list*

......................................................................
6.1 Global Actions                               *nvlime-actions-global*

Key actions available in all Nvlime windows:

global
    normal
        close_current_window
            Closes current window. Doesn't work in cl source files and
            in the sldb window it behaves differently.

        keymaps_help
            Opens floating window which describes Nvlime local keymaps.

        close_nvlime_windows
            Closes all Nvlime windows except repl, sldb and compiler
            notes.

        close_floating_window
            Closes last opened plugin floating window.

        scroll_up
            Scrolls up last opened floating window.

        scroll_down
            Scrolls down last opened floating window.

        split_left (only for floating windows)
            Vertically splits to the left side current floating window
            into the last focused non-floating window.

        split_right (only for floating windows)
            Vertically splits to the right side current floating window
            into the last focused non-floating window.

        split_above (only for floating windows)
            Splits to the top side current floating window into the
            last focused non-floating window.

        split_below (only for floating windows)
            Splits to the bottom side current floating window into the
            last focused non-floating window.

......................................................................
6.2 CL Source File Actions                       *nvlime-actions-source*

Key actions available in lisp source files:

lisp
    normal
        interaction_mode
            Interaction Mode. See |nvlime-interaction-mode|.

        load_file
            Load the current file.

        disassemble
            expr
                Disassemble the form under the cursor.

            symbol
                Disassemble the symbol under the cursor.

        set_package
            Specify the package for the current buffer. An input
            buffer would pop up for this. See |nvlime-input-windows|.

        set_breakpoint
            Set a breakpoint at entry to a function. An input buffer
            would pop up, prompting for the function name. See
            |nvlime-input-windows|.

        show_threads
            Show a list of the running threads. See
            |nvlime-thread-list|.

    insert
        space_arglist
            Insert space character and triggers the arglist hint.

        cr_arglist
            Starts new line and triggers the arglist hint.

    normal
        connection
            new
                Connect to Nvlime server.

            switch
                Switch Nvlime connections. This command shows a list of
                connections, and the current connection will be marked
                with an asterisk "*" at the end.

            rename
                Rename the current connection.

            close
                Disconnect from Nvlime server.

    normal
        server
            new
                Run a new Nvlime server and connect to it. To customize
                the server, see |g:nvlime_config.implementation|.

            show
                View the console output of the current server.

            show_selected
                Show a list of Nvlime servers and view the console output
                of the chosen one.

            stop
                Stop the current server.

            stop_selected
                Show a list of Nvlime servers and stop the chosen one.

            rename
                Rename a server.

            restart
                Restart the current server.

    normal
        repl
            send_atom_expr
                If there's an s-expression under the cursor, send it to
                the REPL, else send the atom under the cursor, if any.

            send_atom
                Send the atom under the cursor to the REPL.

            send_expr
                Send the s-expression under the cursor to the REPL.

            send_toplevel_expr
                Send the top-level s-expression under the cursor to the
                REPL.
            prompt
                Open an input buffer and compose a snippet to send to the
                REPL. See |nvlime-input-windows|.

    visual
        repl
            send_selection
                Send the current selection to the REPL.

    normal
        macro
            expand
                Expand the macro under the cursor.

            expand_once
                Expand the macro under the cursor once.

            expand_all
                Expand the macro under the cursor and all nested macros.

    normal
        compile
            expr
                Compile the form under the cursor.

            toplevel_expr
                Compile the top-level form under the cursor.

            file
                Compile the current file.

    visual
        compile
            selection
                Compile the current selection.

    normal
        xref
            function
                callers
                    Show callers of the function under the cursor.

                callees
                    Show callees of the function under the cursor.

            symbol
                references
                    Show references of the variable under the cursor.

                bindings
                    Show bindings of the variable under the cursor.

                definition
                    Show the definition for the name under the cursor.

                set_locations
                    Show who sets the value of the variable under the cursor.

            macro
                callers
                    Show who expands the macro under the cursor.

            class
                methods
                    Show specialized methods for the class under the cursor.

            prompt
                Interactively prompt for the symbol to search. A menu will
                pop up, to let you choose from xref types. You can prepend
                a count to skip this menu, e.g. "8<LocalLeader>xi" would
                look for definitions. See |nvlime-input-windows|.

    normal
        describe
            operator
                Describe the "operator" of the s-expression under the
                cursor.

            atom
                Describe the atom under the cursor.

            prompt
                Prompt for the symbol to describe. See
                |nvlime-input-windows|.

        apropos
            prompt
                Apropos search. An input buffer would pop up, prompting
                for the search pattern. See |nvlime-input-windows|.

        arglist
            show
                Show the arglist for the s-expression under the cursor.

        documentation
            operator
                Show the documentation for the "operator" of the
                s-expression under the cursor.

            atom
                Show the documentation for the atom under the cursor.

            prompt
                Show the documentation for the symbol entered in an input
                buffer. See |nvlime-input-windows|.

    normal
        inspect
            atom_expr
                If there's an s-expression under the cursor, evaluate it,
                else evaluate the atom under the cursor, if any. The
                evaluation result is then shown in the inspector.

            atom
                Evaluate and inspect the atom under the cursor.

            expr
                Evaluate and inspect the s-expression under the cursor.

            toplevel_expr
                Evaluate and inspect the top-level s-expression under the
                cursor.

            symbol
                Inspect the symbol under the cursor.

            prompt
                Prompt for the expression to inspect. See
                |nvlime-input-windows|.

    visual
        inspect
            selection
                Evaluate and inspect the current selection.

    normal
        trace
            show
                Show the trace dialog.
            toggle
                Toggle the traced state of the function name under the
                cursor.
            prompt
                Show an input buffer, and prompt for the name of the
                function to be traced. See |nvlime-input-windows|. You can
                also trace setf expanders by specifying "(setf <name>)".

    normal
        undefine
            function
                Undefine the function under the cursor.
            symbol
                Unintern the symbol under the cursor.
            prompt
                Interactively prompt for the function/symbol to
                undefine/unintern. A menu will pop up, to let you choose
                what to do. You can prepend a count to skip this menu,
                e.g. "2<LocalLeader>ui" would unintern a symbol. See
                |nvlime-input-windows|.

......................................................................
6.3 Input Window Actions                          *nvlime-actions-input*

Key actions avaialble in the input window:

input
    normal
        complete
            Complete the input.

    insert
        keymaps_help
            Show keymaps help.

        complete
            Complete the input.

        next_history
            Show the next item in input history.

        prev_history
            Show the previous item in input history.

        leave_insert
            Closes the input window when cursor is on the
            first line and first column. Otherwise just
            returns into normal mode.

......................................................................
6.4 REPL Actions                                   *nvlime-actions-repl*

Key actions avaialble in the REPL buffer:

repl
    normal
        interrupt
            Interrupt the REPL thread.

        clear
            Clear the REPL buffer.

        inspect_result
            Inspect the evaluation result under the cursor.

        yank_kesult
            Yank the evaluation result under the cursor into the default
            register |quotequote|. Note that this yanked value is an
            expression to be evaluated in the same REPL session. It is
            meaningless in other contexts.

        next_result
            Move the cursor to the next prensented object.

        previous
            Move the cursor to the previous presented object.

......................................................................
6.5 Debugger Actions                         *nvlime-actions-debugger*

Key actions available in the debugger:

sldb
    normal
        action
            Choose a restart, toggle a frame details or jump to the
            source code.

        frame
            toggle_details
                Show the details (local variables and source location etc.)
                of the frame under the cursor.

            source
                Jump to the source code for the frame under the cursor. If the
                source file is already opened in a window, simply move the
                cursor to that window. Otherwise, this command opens the
                source file in the current window by default. A count can be
                prepended to specify which window to use. For example, "2S"
                would open the source file in the second visible window.

            source_split
                Same as `source` but open the source file in a new split.

            source_vsplit
                Same as `source` but open the source file in a new vertical split.

            source_tab
                Like `source`, but open the source file in a new tab, if it's not
                yet opened in any window.

            restart
                Restart the frame under the cursor.

            eval_expr
                Evaluate an expression in the frame under the cursor. An input
                buffer would pop up, prompting for the expression. See
                |nvlime-input-windows|.

            send_expr
                Evaluate an expression in the frame under the cursor, and then
                send the result to the REPL, so that you can yank the value
                with `repl.normal.yank` and further manipulate it. An
                input buffer would pop up, prompting for the expression. See
                |nvlime-input-windows|.

            disassemble
                Disassemble the frame under the cursor.

            return_result
                Return a manually specified result from the frame under the
                cursor. An input buffer would pop up, prompting for the
                expression that would generate the result. See
                |nvlime-input-windows|.
            step
                Start stepping in the frame under the cursor.

        local_var
            source
                Open the source code for a local variable.

            inspect
                Evaluate and inspect local variable in the frame under the
                cursor. An input window would pop up, prompting for the
                expression if was invoked not on some particular
                variable. See |nvlime-input-windows|.

        step_over
            Step over the current function call.

        step_out
            Step out of the current function.

        abort
            Invoke the restart labeled ABORT.

        continue
            Invoke the restart labeled CONTINUE.

        inspect_condition
            Inspect the current condition object.


......................................................................
6.6 Apropos Actions                             *nvlime-actions-apropos*

Key actions avaialble in the apropos window:

apropos
    normal
        inspect
            Inspect current symbol.

......................................................................
6.7 Inspector Actions                         *nvlime-actions-inspector*

Key actions avaialble in the inspector:

inspector
    normal
        action
            Activate the interactable field/button under the cursor.

        current
            send
                Send the value of the field under the cursor to the REPL.

            source
                Open the source code for the value of the field under
                the cursor.

        inspected
            send
                Send the value being inspected to the REPL.

            source
                Open the source code for the value being inspected.

            previous
                Return to the previous inspected object.

            next
                Move to the next inspected object.

        next_field
            Select the next interactable field/button.

        prev_field
            Select the previous interactable field/button.

        refresh
            Refresh the inspector.

......................................................................
6.8 Compiler Notes Actions                        *nvlime-actions-notes*

notes
    normal
        source
            Jump to the selected source location. If the source file is
            already opened, simply move the cursor to the window
            containing that file. Otherwise, open the source file in the
            window where the command was initiated. A count can be
            prepended to specify which window to use. For example, "2<CR>"
            would show the source file in the second visible window.

        source_split
            Open the selected source location in a horizontal split
            window.

        source_vsplit
            Like `source_split`, but open a vertical split window.

        source_tab
            Like `source`, but open the source file in a new tab, if
            it's not yet opened in any window.

......................................................................
6.9 Server Window Actions                        *nvlime-actions-server*

Key mappings avaialble in the server output window:

server
    normal
        connect
            Connect to this server.

        stop
            Stop this server.

......................................................................
6.10 Thread List Actions                        *nvlime-actions-threads*

Key mappings avaialble in the thread list:

threads
    normal
        interrupt
            Interrupt the thread under the cursor. The debugger will be
            activated.

        kill
            Kill the thread under the cursor.

        invoke_debugger
            Invoke the debugger in the thread under the cursor.

        refresh
            Refresh the thread list.

......................................................................
6.11 Trace Dialog Mappings                 *nvlime-actions-trace-dialog*

Key mappings avaialble in the trace dialog:

trace
    normal
        action
            Activate the interactable field/button under the cursor.

        refresh
            Refresh the trace dialog.

        inspect_value
            Inspect the value of the field under the cursor.

        send_value
            Send the value of the field under the cursor to the REPL.

        next_field
            Select the next interactable field/button.

        prev_field
            Select the previous interactable field/button.

......................................................................
6.12 XRef List Actions                             *nvlime-actions-xref*

Key mappings avaialble in the cross reference list window:

xref
    normal
        source
            Jump to the selected source location. If the source file is
            already opened, simply move the cursor to the window
            containing that file. Otherwise, open the source file in the
            window where the xref command was initiated. A count can be
            prepended to specify which window to use. For example, "2<CR>"
            would show the source file in the second visible window.

        source_split
            Open the selected source location in a horizontal split
            window.

        source_vsplit
            Like `source_split`, but open a vertical split window.

        source_tab
            Like `source`, but open the source file in a new tab, if
            it's not yet opened in any window.

......................................................................
6.13 MREPL Window Actions                         *nvlime-actions-mrepl*

Key mappings avaialble in the MREPL window:

mrepl
    normal
        clear
            Clear the MREPL buffer.

        disconnect
            Disconnect from this REPL.

    insert
        space_arglist
            Insert space character and show arglist hint.

        cr_arglist
            Insert a newline and show arglist hint.

        submit
            Submit the text snippet between the last prompt and EOF
            to the REPL.

        interrupt
            Interrupt the MREPL thread.

======================================================================
7. API                                               *nvlime-api-intro*

Nvlime's source code on the Neovim side is roughly organized into these
groups, and some of them are exported to be user-callable APIs:

    "nvlime#plugin#..." functions
        Top-level entry points to Nvlime features. Most of Nvlime's key
        mappings are mapped to these functions. Some of these
        functions are exported as APIs. See |nvlime-api-functions|.

    "nvlime#ui#..." functions
        UI-related code, which handles user input and special windows
        etc. Some of these functions are exported as APIs. See
        |nvlime-api-functions|.

    "nvlime#connection#..." functions
        Connection management. Internal use only.

    "nvlime#server#..." functions
        Server management. Internal use only.

    "nvlime#contrib#..." functions
        Support for Swank contrib modules. Internal use only.

    |nvlime-api.NvlimeConnection| object
        The low-level code encapsulating Nvlime's protocol and Swank
        messages. Most of the methods are exported as APIs.

Simply put, when you want to build something on top of Nvlime's
infrastructure, start from the top-level "nvlime#plugin#..." API
functions. Then, if you don't find what you want in the top-level API,
resort to the |nvlime-api.NvlimeConnection| object, and maybe the
"nvlime#ui#..." API functions.

All exported APIs are listed in |nvlime-api-functions| and
|nvlime-api.NvlimeConnection|. You can take a glance at the
documentation to see what exactly a certain group of functions can do.

Note that The API documentation is far from complete. When in doubt,
use the source. And please file an issue if you find any mistake in it
(see |nvlime-contrib|).

======================================================================
8. License                                             *nvlime-license*

This plugin is licensed under the terms of the MIT license. See
LICENSE.txt for details.

======================================================================
9. Bugs                                                   *nvlime-bugs*

* Nvlime is asynchronous. When the server takes too much time to
  process a request, you can still invoke other commands or input
  text, but the delayed result may cause some interference when it
  arrives.

* The Neovim interface may sometimes freeze until a command is issued
  (e.g. move the cursor).

Please file an issue on https://github.com/monkoose/nvlime/issues if
you find any other problem.

======================================================================
10. Contributing                                        *nvlime-contrib*

The source repo for Nvlime is hosted on GitHub:

    https://github.com/monkoose/nvlime

Please send pull requests if you have any suggestions for improving
Nvlime.

                                                         *nvlime-tests*
To make sure Nvlime works as intended on your platform, or to check if
something is broken after patching, it's recommended to run the tests.

To run the tests for the client side, make sure you have the Neovim
plugin properly installed, and then source the test runner script:

    nvim -S <nvlime repo>/vim/test/run_tests.vim

To run the tests for the server side, make sure "<nvlime repo>/lisp"
directory is in your "<quicklisp>/local-projects" directory (or make a
symlink), and then run the tests:

    sbcl --eval "(ql:quickload '(:nvlime-test :nvlime-sbcl-test))" \
         --eval "(test-with-coverage:main '(:nvlime :nvlime-sbcl) \"/path/to/coverage/output/\")" \
         --quit

The coverage output is only available for SBCL. If you're using
another implementation, or don't care about the coverage, just call
"(asdf:test-system ...)" directly. For example, using CCL:

    ccl --eval "(ql:quickload '(:nvlime-test))" \
        --eval "(asdf:test-system 'nvlime)" \
        --eval "(quit)"

The tests (both client-side and server-side) are organized in a rather
simple/naive way. Please refer to the existing test code if you want
to add new tests.
