*nvlime.txt*  A Common Lisp dev environment for Neovim         *nvlime*

======================================================================
CONTENTS                                              *nvlime-contents*

    1. Introduction ................................ |nvlime-intro|
    2. Concepts ................................. |nvlime-concepts|
    3. Usage ....................................... |nvlime-usage|
        3.1 Starting Up ......................... |nvlime-start-up|
        3.2 Completions ...................... |nvlime-completions|
        3.3 Automatic Indentation ............ |nvlime-auto-indent|
        3.4 REPL .................................... |nvlime-repl|
        3.5 Debugger ............................ |nvlime-debugger|
        3.6 Inspector .......................... |nvlime-inspector|
        3.7 Cross References ........................ |nvlime-xref|
        3.8 Compiler Messages ............... |nvlime-compiler-msg|
        3.9 Managing Threads ................. |nvlime-thread-list|
        3.10 Remote Servers ................ |nvlime-remote-server|
        3.11 Input Buffers .................. |nvlime-input-buffer|
        3.12 Trace Dialog ................... |nvlime-trace-dialog|
        3.13 Multiple REPLs ........................ |nvlime-mrepl|
    4. Mappings ................................. |nvlime-mappings|
        4.1 List of Key Mappings ........... |nvlime-mappings-list|
            4.1.1 CL Source File Mappings  |nvlime-mappings-source|
            4.1.2 REPL Buffer Mappings ..... |nvlime-mappings-repl|
            4.1.3 Debugger Mappings .... |nvlime-mappings-debugger|
            4.1.4 Inspector Mappings .. |nvlime-mappings-inspector|
            4.1.5 XRef List & Compiler Notes Mappings ..........
                  .......................... |nvlime-mappings-xref|
            4.1.6 Thread List Mappings .........................
                  ................... |nvlime-mappings-thread-list|
            4.1.7 Server Output Buffer Mappings ................
                  ........................ |nvlime-mappings-server|
            4.1.8 Input Buffer Mappings ... |nvlime-mappings-input|
            4.1.9 Trace Dialog Mappings ........................
                  .................. |nvlime-mappings-trace-dialog|
            4.1.10 MREPL buffer Mappings .. |nvlime-mappings-mrepl|
    5. Configuration .............................. |nvlime-config|
    6. API ..................................... |nvlime-api-intro|
    7. License ................................... |nvlime-license|
    8. Bugs ......................................... |nvlime-bugs|
    9. Contributing .............................. |nvlime-contrib|

======================================================================
1. Introduction                                          *nvlime-intro*

Nvlime is a Common Lisp dev environment for Neovim, similar to SLIME
for Emacs.

It provides REPL integration, as well as omni-completions, cross
reference utilities, a nice inspector, debugger support, and many
other great facilities to aid you in your glorious Common Lisp hacking
quest.

These Common Lisp implementations are supported:

    Implementation  Version  Notes
    ---------------------------------------------------------------
    ABCL            1.4.0    Supported by the nvlime-patched backend
    Allegro CL      10.0     Tested with the Express Edition
    CLISP           2.49+    No multithreading support
    ECL             16.1.3   No debugger support
    CCL             1.11
    SBCL            1.3.13
    LispWorks       6.1      Tested with the Personal Edition

======================================================================
2. Concepts                                           *nvlime-concepts*

Connection                                          *nvlime-connection*
    A connection between Neovim and a Nvlime server. Most of Nvlime's
    functionalities need an active connection to work. Each Neovim
    process can have multiple connections. See |nvlime-mappings-conn|
    for available operations regarding connections.

The Current Connection                      *nvlime-current-connection*
    A connection (|nvlime-connection|) that's bound to the current
    Neovim buffer. All Nvlime operations in the current buffer will use
    this connection. Nvlime will try to choose and remember an open
    connection for a buffer automatically, but it's also possible to
    select one via |nvlime-mappings-conn-cs|.

The Current Package                            *nvlime-current-package*
    A Common Lisp package that's bound to the current Neovim buffer. All
    Nvlime operations that concern about the Common Lisp package, such
    as omni-completions, will use this value. Nvlime will try to figure
    out the current package automatically, but it's also possible to
    specify a package via |nvlime-mappings-misc-p|.

======================================================================
3. Usage                                                 *nvlime-usage*

----------------------------------------------------------------------
3.1 Starting Up                                       *nvlime-start-up*

If you have sbcl in your $PATH, Nvlime can start a server for you:

    1. Set up Quicklisp properly.
    2. Start editing a Common Lisp source file, and use
       |nvlime-mappings-invoke-server-rr| to run a server.
    3. Wait for the server. Nvlime will automatically connect to it
       when it's ready, and become fully operational.

Note: If it's your first time running the server, Nvlime will try to
      install it's dependencies via Quicklisp. This may take some
      time.

See |nvlime-mappings-invoke-server| for more operations on Nvlime
servers, and |nvlime-mappings-server| for operations available in the
server output buffer. See |nvlime-mappings| for all available Nvlime
operations.

When you need to use some other Common Lisp implementation, run an
instance of sbcl in arbitrary locations, or pass special arguments to
the server, use the |g:nvlime_cl_impl| option.

                                             *nvlime-start-up-manually*
You may also start the server manually:

    1. Set up Quicklisp properly.
    2. Run the server:

        sbcl --load <nvlime repo>/lisp/start-nvlime.lisp

    3. Start editing a Common Lisp source file, and use
       |nvlime-mappings-conn-cc| to create a new
       connection.
    4. Nvlime shoud now be fully operational.

                                     *nvlime-start-up-in-running-image*
If you have a running Common Lisp image, and want to start the server
in it:

    1. Make sure the Quicklisp client is loaded (by loading the
       corresponding "setup.lisp" file, for example).
    2. Make sure the "<nvlime repo>/lisp/" directory (or a symlink
       pointing to it) is in your "<quicklisp>/local-projects/"
       directory.
    3. Evaluate "(ql:quickload :nvlime)" to load the bootstrapping
       code.
    4. Evaluate "(nvlime:main)" to start the server, or something like

        (nvlime:main :interface #(127 0 0 1)
                    :port 7002
                    :backend :nvlime-usocket)

       to specify the backend and the address to bind to.

See |nvlime-server-options| for a full list of parameters you can pass
to the NVLIME:MAIN function.

                                               *nvlime-server-backends*
Note that Nvlime's server has three backends:

    :nvlime-usocket          Suitable for environments that support
                            multithreading. Depends on usocket.

    :nvlime-sbcl             Suitable for SBCL without multithreading.
                            Only works on Linux/Unix systems. Depends
                            on SBCL-specific APIs.

    :nvlime-patched          Suitable for other environments. Patches
                            Swank to support the Nvlime protocol. Has
                            the least dependencies.

The bootstrapping code takes special measures to automatically detect
and load the correct backend. Usually you can just omit the :BACKEND
argument of the NVLIME:MAIN function.

                                    *nvlime-include-server-in-cl-image*
To include the Nvlime server in your Common Lisp image, just load the
NVLIME system and at least one backend that works for your. For
example, a typical SBCL image can be generated by:

    (ql:quickload :nvlime)
    (ql:quickload :nvlime-usocket)
    (sb-ext:save-lisp-and-die ...)

To start the server, call "(nvlime:main :backend :nvlime-usocket)" in
your running image.

                                                  *nvlime-slime-secret*
When connecting to a server, Nvlime will try to use the file
"$HOME/.slime-secret" to authenticate the connection. Just put one
single line containing a secret phrase in this file, make sure it's
readable, and Nvlime will automatically enable authentication for all
connections.

                                                *nvlime-server-options*
The server entry point (i.e. the NVLIME:MAIN function) accepts some
keyword arguments to allow the caller to fine-tune server behavior:

    :backend
        One of the backends listed in |nvlime-server-backends|, or NIL
        to let the server choose a backend automatically. Default: NIL

    :interface
        A vector specifying the IP address of the interface to bind
        to. Default: #(127 0 0 1)

    :port
        An integer specifying the TCP port number to listen on. A
        value of zero tells the server to choose an arbitrary port.
        Default: 0

    :port-file
        If this argument is not NIL, the server will write the port
        number on which it's listening in the specified file, once the
        server is fully operational. Default: NIL

    :start-swank
        Whether to start a Swank server or not. Usually the Nvlime
        server will start a Swank server automatically, and relay all
        requests to it. If you have a Swank server that's already
        running, and you want to use that instead, pass NIL to this
        argument, and point :swank-interface and :swank-port to the
        existing Swank server. Default: T

    :swank-interface
        When the :start-swank argument is T, this argument specifies
        the interface that the new Swank server binds to. Otherwise
        this should be the interface for a running Swank server.
        Default: #(127 0 0 1)

    :swank-port
        When the :start-swank argument is T, this argument specifies
        the port that the new Swank server listens on. Otherwise this
        should be the port for a running Swank server. Default: 0

    :dont-close
        Do not shutdown the server after the first connection. Pass
        NIL to allow one client only. Default: T

----------------------------------------------------------------------
3.2 Completions                                    *nvlime-completions*

----------------------------------------------------------------------
3.3 Automatic Indentation                          *nvlime-auto-indent*

The auto indent feature will just work as you type. It supports both
space and tab characters. Which to use is determined by the
|expandtab| Neovim option.

To adjust mis-indented lines, press <Tab> at the start of those lines
in insert mode, or use |=| command.

Nvlime has a set of indent rules that are similar to the ones SLIME
used. Multi-line expressions are generally indented by the width of
two space characters, regardless of the value of |shiftwidth|. Macros
and special operators with "&BODY" arguments are treated specially, in
that all the arguments before "&BODY" will be indented one more level.
For example, MULTIPLE-VALUE-BIND has two arguments before "&BODY", so
a call to it will be indented this way:

    (multiple-value-bind
        (val exist-p)
        (gethash "key" hash-table)
      (do-something)
      (do-other-thing))

You can control how an operator and its arguments are indented using
|g:nvlime_indent_keywords|.

----------------------------------------------------------------------
3.4 REPL                                                  *nvlime-repl*

The REPL integration is different from other Lisp environments, in
that Nvlime's REPL buffer is read-only. One can send expressions to the
REPL from any lisp source buffer using normal mode commands such as
|nvlime-mappings-send-ss|, instead of typing the input directly in the
REPL buffer.

Note: It's a design decision to make the REPL buffer read-only, since
      emulating a command line in Neovim buffers is often complicated
      and buggy.

When the REPL needs user input, e.g. (read) or (read-line) is being
evaluated, a dedicated window for string input would pop up. Write
the input inside this buffer, and hit <CR> in normal mode, then the
REPL would receive your text. The input buffer is a generic mechanism
for the commands that need user input. See |nvlime-input-buffer|.

                                              *nvlime-interaction-mode*
There's an interaction mode to make sending things to the REPL easier.
It's enabled via |nvlime-mappings-misc-<CR>| in Common Lisp source
buffers. In this mode, simply pressing <CR> will send the s-expression
under the cursor.

One can inspect the evaluation results right from the REPL buffer. See
|nvlime-mappings-repl| for key mappings.

----------------------------------------------------------------------
3.5 Debugger                                          *nvlime-debugger*

The debugger works just like SLDB in SLIME. It pops up a buffer when a
condition is signalled. The buffer shows a list of restarts and a
backtrace. One can press <CR> on a restart to select it.

The debugger can also do single-stepping, examine the local variables,
restart frames, evaluate expressions in frames, etc., provided the
Common Lisp implementation Nvlime server is running on supports these.
For more available operations in the debugger buffer, see
|nvlime-mappings-debugger|.

Note: Some debugger features are not supported by some Common Lisp
      implementations. These unsupported operations will most likely
      result in an error message.

----------------------------------------------------------------------
3.6 Inspector                                        *nvlime-inspector*

The inspector can be used to examine the slot values of instances,
the members of structs, the items of hashtables, etc. It's a very
handy tool in many circumstances.

There're multiple ways to invoke the inspector, but the most
convenient one is using |nvlime-mappings-invoke-inspector-ii| on an
expression.

The content shown in the inspector buffer usually contains multiple
interactable fields and buttons. Pressing <Tab> will move the cursor
between theses fields/buttons, and <CR> interact with them. If the
interaction needs extra user input, an input buffer would pop up. See
|nvlime-input-buffer|.

For more available operations in the inspector buffer, see
|nvlime-mappings-inspector|.

----------------------------------------------------------------------
3.7 Cross References                                      *nvlime-xref*

The cross references (a.k.a xref) buffer shows where a symbol is
referenced. For example, use |nvlime-mappings-invoke-xref-xc| on a
function name to see where the function is called. Pressing <CR> on an
entry inside the xref buffer will take you directly to the reference
location.

For more xref types and key mappings, see
|nvlime-mappings-invoke-xref|. For all available key mappings in the
xref buffer, see |nvlime-mappings-xref|.

----------------------------------------------------------------------
3.8 Compiler Messages                             *nvlime-compiler-msg*

When issuing compilation commands specified in
|nvlime-mappings-compile|, any message (warnings and errors etc.)
emitted by the compiler would pop up in a dedicated buffer. Just
select a message by pressing <CR>, and Nvlime will take you to the
referenced source location.

For all available key mappings in the compiler message buffer, see
|nvlime-mappings-compiler-notes|.

----------------------------------------------------------------------
3.9 Managing Threads                               *nvlime-thread-list*

For CL implementations that support threads, there's a window that
shows all running threads. Use |nvlime-mappings-misc-T| to show it.

While in the thread list, you can perform tasks such as killing a
thread, or activating the debugger in a thread. See
|nvlime-mappings-thread-list| for a full list of available operations.

----------------------------------------------------------------------
3.10 Remote Servers                              *nvlime-remote-server*

Nvlime can connect to a server running on a remote machine. The most
secure way is to use SSH tunnels. Say we want to run a Nvlime server on
Mars:

    ssh watney@mars-hab \
        -L 7002:localhost:7002 \
        sbcl --load <nvlime repo>/lisp/start-nvlime.lisp

This command will also set up local port forwarding, so that we can
connect to the server right here on Earth. Then, in Neovim, call
nvlime#plugin#ConnectREPL():

    :call nvlime#plugin#ConnectREPL("127.0.0.1", 7002, "sftp://watney@mars-hab/", 5000)

The third argument is an SFTP URL to tell Nvlime that all filenames
returned by the server resides in the remote machine, and should be
opened through SFTP. The last argument is the time to wait for the
connection to be made, in milliseconds (Let's just pretend we can
connect to Mars in 5 seconds). When running through a network with
high latency, you may want to raise this value.

Note: When connecting to a remote server, relative file paths may
      cause problems. Please make sure the remote Nvlime server runs in
      the directory that your paths are relative to. Nvlime always
      tries to use absolute paths.

----------------------------------------------------------------------
3.11 Input Windows                               *nvlime-input-windows*

When Nvlime needs user input, a dedicated input window would pop up.
One can use it to compose any text snippet in it, and then press <CR>
in insert or normal mode to submit the snippet to Nvlime.

If the operation that brought up the input buffer can be cancelled,
submitting an empty snippet would usually cancel that operation.

Submitted text snippets are remembered as a linear input history. You
can move to the previous/next item in history with <C-p>/<C-n>. See
|nvlime-mappings-input|.

----------------------------------------------------------------------
3.12 Trace Dialog                                 *nvlime-trace-dialog*

Note: This feature needs the SWANK-TRACE-DIALOG contrib module. See
      |g:nvlime_contribs| and |nvlime#plugin#SwankRequire()|.

Nvlime can trace functions and show the results in a dedicated window
for you. It's called the trace dialog, named after the similar
component in SLIME. One can use
|nvlime-mappings-invoke-trace-dialog-td| to have it open.

The trace dialog will show two kinds of info: a list of traced
functions, and the trace results. It also contains multiple
interactable fields and buttons. You can navigate through these
fields/buttons by pressing <Tab>, and interact with them using <CR>.

Nested trace entries are folded by default. Use standard
|fold-commands| to handle the |folds|.

For more available operations for the trace dialog, see
|nvlime-mappings-trace-dialog|, and
|nvlime-mappings-invoke-trace-dialog|.

----------------------------------------------------------------------
3.13 Multiple REPLs                                      *nvlime-mrepl*

Note: This feature needs the SWANK-MREPL contrib module. See
      |g:nvlime_contribs| and |nvlime#plugin#SwankRequire()|. And it
      works best on CL implementations with multithreading support.

Nvlime usually creates a single REPL upon connection. If this REPL were
blocked by a time-consuming operation, the server may seem
unresponsive. The multiple REPL support may come in handy in this
case.

One can call |nvlime#plugin#CreateMREPL()| to spawn a new REPL, and
open an "mrepl" command line buffer automatically. Just enter |Insert|
mode and use it as you may use any other REPL prompts. But note that
the command line is somewhat fragile, in that it is implemented by
simply extracting the text between the last prompt string and EOF.
Modifying text outside this range may cause unexpected bahavior.

See |nvlime-mappings-mrepl| for all available operations in the MREPL
buffer.

======================================================================
4. Mappings                                           *nvlime-mappings*

Most normal mode and visual mode mappings in Nvlime starts with
|<LocalLeader>|, which defaults to the backslash "\". If you feel
uncomfortable reaching out for the backslash key, you may change it by
adding this line to your |init.vim| file, to use the comma instead:

    let maplocalleader = ","

Or, if you don't want to change your |<LocalLeader>|, set
|g:nvlime_leader| instead:

    let g:nvlime_leader = ","

You can type "<LocalLeader>?" (without the quote marks) in most of
Nvlime buffers, including Common Lisp source files, to see a quick
reference for the exact mappings defined in those buffers.

----------------------------------------------------------------------
4.1 List of Key Mappings                         *nvlime-mappings-list*

All the mappings listed below are defined in normal mode, unless
specified otherwise.

......................................................................
4.1.1 CL Source File Mappings                  *nvlime-mappings-source*

Key mappings available in lisp source files:

    Connection Management                        *nvlime-mappings-conn*
        <LocalLeader>cc                       *nvlime-mappings-conn-cc*
            Connect to Nvlime server.
        <LocalLeader>cs                       *nvlime-mappings-conn-cs*
            Switch Nvlime connections. This command shows a list of
            connections, and the current connection will be marked
            with an asterisk "*" at the end.
        <LocalLeader>cd
            Disconnect.
        <LocalLeader>cR
            Rename the current connection.

    Server Management                   *nvlime-mappings-invoke-server*
        <LocalLeader>rr              *nvlime-mappings-invoke-server-rr*
            Run a new Nvlime server and connect to it. To customize the
            server, see |g:nvlime_cl_impl|.
        <LocalLeader>rv
            View the console output of the current server.
        <LocalLeader>rV
            Show a list of Nvlime servers and view the console output of the chosen one.
        <LocalLeader>rt
            Restart the current server.
        <LocalLeader>rs              *nvlime-mappings-invoke-server-rs*
            Stop the current server.
        <LocalLeader>rS
            Show a list of Nvlime servers and stop the chosen one.
        <LocalLeader>rR
            Rename a server.

    Sending Stuff To The REPL                    *nvlime-mappings-send*
        <LocalLeader>ss                       *nvlime-mappings-send-ss*
            If there's an s-expression under the cursor, send it to
            the REPL, else send the atom under the cursor, if any.
        <LocalLeader>se
            Send the s-expression under the cursor to the REPL.
        <LocalLeader>st
            Send the top-level s-expression under the cursor to the
            REPL.
        <LocalLeader>sa
            Send the atom under the cursor to the REPL.
        <LocalLeader>si
            Open an input buffer and compose a snippet to send to the
            REPL. See |nvlime-input-buffer|.
        <LocalLeader>s
            (In visual mode) Send the current selection to the REPL.

    Expanding Macros                    *nvlime-mappings-expand-macros*
        <LocalLeader>mm
            Expand the macro under the cursor.
        <LocalLeader>m1
            Expand the macro under the cursor once.
        <LocalLeader>ma
            Expand the macro under the cursor and all nested macros.

    Compiling                                 *nvlime-mappings-compile*
        <LocalLeader>ce
            Compile the form under the cursor.
        <LocalLeader>ct
            Compile the top-level form under the cursor.
        <LocalLeader>cf
            Compile the current file.
        <LocalLeader>c
            (In visual mode) Compile the current selection.

    Cross References (xref)               *nvlime-mappings-invoke-xref*
        <LocalLeader>xc                *nvlime-mappings-invoke-xref-xc*
            Show callers of the function under the cursor.
        <LocalLeader>xC
            Show callees of the function under the cursor.
        <LocalLeader>xr
            Show references of the variable under the cursor.
        <LocalLeader>xb
            Show bindings of the variable under the cursor.
        <LocalLeader>xs
            Show who sets the value of the variable under the cursor.
        <LocalLeader>xe
            Show who expands the macro under the cursor.
        <LocalLeader>xm
            Show specialized methods for the class under the cursor.
        <LocalLeader>xd
            Show the definition for the name under the cursor.
        <LocalLeader>xi
            Interactively prompt for the symbol to search. A menu will
            pop up, to let you choose from xref types. You can prepend
            a count to skip this menu, e.g. "8<LocalLeader>xi" would
            look for definitions. See |nvlime-input-buffer|.

    Describing Things                        *nvlime-mappings-describe*
        <LocalLeader>do
            Describe the "operator" of the s-expression under the
            cursor.
        <LocalLeader>da
            Describe the atom under the cursor.
        <LocalLeader>di
            Prompt for the symbol to describe. See
            |nvlime-input-buffer|.
        <LocalLeader>ds
            Apropos search. An input buffer would pop up, prompting
            for the search pattern. See |nvlime-input-buffer|.
        <LocalLeader>ddo
            Show the documentation for the "operator" of the
            s-expression under the cursor.
        <LocalLeader>dda
            Show the documentation for the atom under the cursor.
        K
            Show the documentation for the atom under the cursor.
        <LocalLeader>ddi
            Show the documentation for the symbol entered in an input
            buffer. See |nvlime-input-buffer|.
        <LocalLeader>dr
            Show the arglist for the s-expression under the cursor.

    Undefining Things
        <LocalLeader>uf
            Undefine the function under the cursor.
        <LocalLeader>us
            Unintern the symbol under the cursor.
        <LocalLeader>ui
            Interactively prompt for the function/symbol to
            undefine/unintern. A menu will pop up, to let you choose
            what to do. You can prepend a count to skip this menu,
            e.g. "2<LocalLeader>ui" would unintern a symbol. See
            |nvlime-input-buffer|.

    Inspection                       *nvlime-mappings-invoke-inspector*
        <LocalLeader>ii           *nvlime-mappings-invoke-inspector-ii*
            If there's an s-expression under the cursor, evaluate it,
            else evaluate the atom under the cursor, if any. The
            evaluation result is then shown in the inspector.
        <LocalLeader>ie
            Evaluate and inspect the s-expression under the cursor.
        <LocalLeader>it
            Evaluate and inspect the top-level s-expression under the
            cursor.
        <LocalLeader>ia
            Evaluate and inspect the atom under the cursor.
        <LocalLeader>is
            Inspect the symbol under the cursor.
        <LocalLeader>in
            Prompt for the expression to inspect. See
            |nvlime-input-buffer|.
        <LocalLeader>i
            (In visual mode) Evaluate and inspect the current
            selection.

    Invoking The Trace Dialog     *nvlime-mappings-invoke-trace-dialog*
        <LocalLeader>td        *nvlime-mappings-invoke-trace-dialog-td*
            Show the trace dialog.
        <LocalLeader>tt
            Toggle the traced state of the function name under the
            cursor.
        <LocalLeader>ti
            Show an input buffer, and prompt for the name of the
            function to be traced. See |nvlime-input-buffer|. You can
            also trace setf expanders by specifying "(setf <name>)".

    Other Stuff                                  *nvlime-mappings-misc*
        <LocalLeader><CR>                   *nvlime-mappings-misc-<CR>*
            Interaction Mode. See |nvlime-interaction-mode|.
        <LocalLeader>l
            Load the current file.
        <LocalLeader>a
            Disassemble the form under the cursor.
        <LocalLeader>p                         *nvlime-mappings-misc-p*
            Specify the package for the current buffer. An input
            buffer would pop up for this. See |nvlime-input-buffer|.
        <LocalLeader>b
            Set a breakpoint at entry to a function. An input buffer
            would pop up, prompting for the function name. See
            |nvlime-input-buffer|.
        <LocalLeader>T                         *nvlime-mappings-misc-T*
            Show a list of the running threads. See
            |nvlime-thread-list|.

......................................................................
4.1.2 REPL Buffer Mappings                       *nvlime-mappings-repl*

Key mappings avaialble in the REPL buffer:

    CTRL-c
        Interrupt the REPL thread.
    i
        Inspect the evaluation result under the cursor.
    y                                          *nvlime-mappings-repl-y*
        Yank the evaluation result under the cursor into the default
        register |quotequote|. Note that this yanked value is an
        expression to be evaluated in the same REPL session. It is
        meaningless in other contexts.
    C
        Clear the REPL buffer.
    <Tab>
        Move the cursor to the next prensented object.
    <S-Tab>
        Move the cursor to the previous presented object.
    CTRL-n
        Same as <Tab>.
    CTRL-p
        Same as <S-Tab>.

......................................................................
4.1.3 Debugger Mappings                      *nvlime-mappings-debugger*

Key mappings available in the debugger:

    <CR>
        Choose a restart, toggle a frame info or jump to the
        source code.
    d
        Show the details (local variables and source location etc.)
        of the frame under the cursor.
    S
        Jump to the source code for the frame under the cursor. If the
        source file is already opened in a window, simply move the
        cursor to that window. Otherwise, this command opens the
        source file in the current window by default. A count can be
        prepended to specify which window to use. For example, "2S"
        would open the source file in the second visible window.
    CTRL-t
        Like "S", but open the source file in a new tab, if it's not
        yet opened in any window. To always create a new tab, prepend
        an arbitrary count, such as "1<C-t>".
    CTRL-s
        Same as CTRL-t but open the source file in a new split.
    CTRL-v
        Same as CTRL-t but open the source file in a new vertical split.
    O
        Open the source code for a local variable.
    r
        Restart the frame under the cursor.
    s
        Start stepping in the frame under the cursor.
    x
        Step over the current function call.
    o
        Step out of the current function.
    c
        Invoke the restart labeled CONTINUE.
    a
        Invoke the restart labeled ABORT.
    C
        Inspect the current condition object.
    i                                      *nvlime-mappings-debugger-i*
        Evaluate and inspect an expression in the frame under the
        cursor. An input buffer would pop up, prompting for the
        expression. See |nvlime-input-buffer|.
    e
        Evaluate an expression in the frame under the cursor. An input
        buffer would pop up, prompting for the expression. See
        |nvlime-input-buffer|.
    E
        Evaluate an expression in the frame under the cursor, and then
        send the result to the REPL, so that you can yank the value
        with |nvlime-mappings-repl-y| and further manipulate it. An
        input buffer would pop up, prompting for the expression. See
        |nvlime-input-buffer|.
    D
        Disassemble the frame under the cursor.
    R
        Return a manually specified result from the frame under the
        cursor. An input buffer would pop up, prompting for the
        expression that would generate the result. See
        |nvlime-input-buffer|.

......................................................................
4.1.4 Inspector Mappings                    *nvlime-mappings-inspector*

Key mappings avaialble in the inspector:

    <CR>
        Activate the interactable field/button under the cursor.
    s
        Send the value of the field under the cursor to the REPL.
    S
        Send the value being inspected to the REPL.
    o
        Open the source code for the value of the field under
        the cursor.
    O
        Open the source code for the value being inspected.
    <Tab>
        Select the next interactable field/button.
    CTRL-n
        Same as <Tab>
    CTRL-p
        Select the previous interactable field/button.
    CTRL-o
        Return to the previous inspected object.
    CTRL-i
        Move to the next inspected object.
    R
        Refresh the inspector.

......................................................................
4.1.5 XRef List & Compiler Notes Mappings
                                                 *nvlime-mappings-xref*
                                       *nvlime-mappings-compiler-notes*

Key mappings avaialble in the cross reference list and the compiler
notes window:

    <CR>
        Jump to the selected source location. If the source file is
        already opened, simply move the cursor to the window
        containing that file. Otherwise, open the source file in the
        window where the xref command was initiated. A count can be
        prepended to specify which window to use. For example, "2<CR>"
        would show the source file in the second visible window.
    CTRL-t
        Like <CR>, but open the source file in a new tab, if it's not
        yet opened in any window.
    CTRL-s
        Open the selected source location in a horizontal split
        window. A count can be prepended to specify which window to
        split.
    CTRL-v
        Like "CTRL-s", but open a vertical split window.

......................................................................
4.1.6 Thread List Mappings                *nvlime-mappings-thread-list*

Key mappings avaialble in the thread list:

    CTRL-c
        Interrupt the thread under the cursor. The debugger will be
        activated.
    K
        Kill the thread under the cursor.
    D
        Invoke the debugger in the thread under the cursor.
    r
        Refresh the thread list.

......................................................................
4.1.7 Server Output Buffer Mappings            *nvlime-mappings-server*

Key mappings avaialble in the server output buffer:

    <LocalLeader>c                           *nvlime-mappings-server-c*
        Connect to this server.
    <LocalLeader>s
        Stop this server.

......................................................................
4.1.8 Input Buffer Mappings                     *nvlime-mappings-input*

Key mappings avaialble in the input buffer:

    <CR>
        Complete the input.
    <CR>
        (In insert mode) Complete the input.
    CTRL-p
        (In insert mode) Show the previous item in input history.
    CTRL-n
        (In insert mode) Show the next item in input history.

......................................................................
4.1.9 Trace Dialog Mappings              *nvlime-mappings-trace-dialog*

Key mappings avaialble in the trace dialog:

    <CR>
        Activate the interactable field/button under the cursor.
    <Space>
        Same as <CR>.
    s
        Send the value of the field under the cursor to the REPL.
    i
        Inspect the value of the field under the cursor.
    <Tab>
        Select the next interactable field/button.
    CTRL-n
        Same as <Tab>.
    CTRL-p
        Select the previous interactable field/button.
    R
        Refresh the trace dialog.

......................................................................
4.1.10 MREPL Buffer Mappings                    *nvlime-mappings-mrepl*

Key mappings avaialble in the MREPL buffer:

    <CR>
        (In insert mode) Submit the text snippet between the last
        prompt and EOF to the REPL.
    CTRL-j
        (In insert mode) Insert a newline.
    <Tab>
        (In insert mode) Trigger omni-completion.
    CTRL-c
        (In insert mode) Interrupt the MREPL thread.
    <LocalLeader>C
        Clear the MREPL buffer.
    <LocalLeader>D
        Disconnect from this REPL.

======================================================================
5. Configuration                                        *nvlime-config*

These variables can be set in |init.vim|, to affect the behavior of
Nvlime:

g:nvlime_leader                                        *g:nvlime_leader*
    A |string| to override the leader key used in Nvlime key mappings.
    This supersedes |maplocalleader|. Please use key notations for
    special keys, as described in |key-notation|. For example, setting
    this variable to "<Space>" would instruct Nvlime to use the space
    key as the leader. Also see |nvlime-mappings|. Default:
    "<LocalLeader>"

g:nvlime_cl_impl                                      *g:nvlime_cl_impl*
    A |string| to designate the CL implementation to use when starting
    a server via |nvlime-mappings-invoke-server-rr|. This option has no
    effect when connecting to an existing server via
    |nvlime-mappings-conn-cc|. Default: "sbcl"

    You can define a function named
    "NvlimeBuildServerCommandFor_<impl>" to build a command line for
    your implementation. For maximum compatibility, this function
    should return a list containing all the command line components.
    See |job_start()| in Neovim or |jobstart()| in Neovim for detailed
    explanation on command lines.

    For example, to use a custom SBCL and a custom Quicklisp setup,
    add these to your |init.vim|:

        let g:nvlime_cl_impl = "my_sbcl"
        function! NvlimeBuildServerCommandFor_my_sbcl(nvlime_loader, nvlime_eval)
            return ["/path/to/my/custom/sbcl",
                        \ "--load", "/path/to/my/custom/quicklisp/setup.lisp",
                        \ "--load", a:nvlime_loader,
                        \ "--eval", a:nvlime_eval]
        endfunction

    Or, if you prefer using Roswell to manage your implementations:

        let g:nvlime_cl_impl = "ros"
        function! NvlimeBuildServerCommandFor_ros(nvlime_loader, nvlime_eval)
            return ["ros", "run",
                        \ "--load", a:nvlime_loader,
                        \ "--eval", a:nvlime_eval]
        endfunction

    Then restart Neovim and call nvlime#server#BuildServerCommand() to see
    whether the new command is OK:

        :echo nvlime#server#BuildServerCommand()

    The command returned by nvlime#server#BuildServerCommand() will be
    executed to start a Nvlime server when the
    |nvlime-mappings-invoke-server-rr| command is invoked.

    Nvlime has these builder functions predefined:

        " For SBCL, the default
        nvlime#server#BuildServerCommandFor_sbcl()
        " For Clozure CL, set g:nvlime_cl_impl to "ccl"
        nvlime#server#BuildServerCommandFor_ccl()

    If you use other implementations, such as clisp and abcl, or need
    to pass special arguments to the server, you'll need to define the
    builder functions.

Note: If you use symlinks on Windows systems to point to Nvlime, it may
      fail to locate the server entry point automatically. In this
      case you'll have to define a command builder function and
      overwrite "nvlime_loader" with the absolute path of
      "load-nvlime.lisp":

          function! NvlimeBuildServerCommandFor_xxx(nvlime_loader, nvlime_eval)
              return ["sbcl",
                          \ "--load", "c:\\path\\to\\nvlime\\lisp\\load-nvlime.lisp",
                          \ "--eval", a:nvlime_eval]
          endfunction

g:nvlime_cl_wait_time                            *g:nvlime_cl_wait_time*
    DEPRECATED: Nvlime now uses async callbacks to handle server
    start-up/tear-down events. Setting this option has no effect at
    all.

    An integer specifying the time Nvlime should wait when starting a
    server via |nvlime-mappings-invoke-server-rr|, or stopping a server
    via |nvlime-mappings-invoke-server-rs|, in seconds. Default: 10

g:nvlime_address                                      *g:nvlime_address*
    A |list| specifying the default address of the Nvlime server. This
    address will be used as the default host and port values in the
    |nvlime-mappings-conn-cc| command. Default: ["127.0.0.1", 7002]

g:nvlime_connect_timeout                      *g:nvlime_connect_timeout*
    An integer specifying the time to wait when connecting to the
    server, in milliseconds. If set to |v:null|, Nvlime would try to
    use the default timeout values on different platforms. Default:
    v:null

g:nvlime_compiler_policy                      *g:nvlime_compiler_policy*
    A |dict| to hold the compiler policy. Setting this variable would
    affect the subsequent compiling operations. For example, a value
    of {"DEBUG": 3, "SPEED": 0} means no optimization in runtime
    speed, and maximum debug info. Note that the keys are
    case-sensitive. Please use only uppercase. Default: {}

g:nvlime_indent_keywords                      *g:nvlime_indent_keywords*
    A |dict| specifying indent rules for operators. The keys should be
    operator names in lowercase, and the values should be the number
    of arguments before "&BODY", or other numbers that you prefer.
    Also see |nvlime-auto-indent|. For example,

        let g:nvlime_indent_keywords = {"dummy-op": 1}

    Will cause a DUMMY-OP expression to be indented this way:

        (dummy-op
            expr1
          expr2
          expr3
          ...)

    And

        let g:nvlime_indent_keywords = {"dummy-op": 2}

    Will cause the same expression to be indented this way:

        (dummy-op
            expr1
            expr2
          expr3
          ...)

    To see the default operator indent settings,

        :echo g:nvlime_default_indent_keywords

g:nvlime_input_history_limit              *g:nvlime_input_history_limit*
    An integer to specify how many input history items to store. A
    non-positive value disables input history. See
    |nvlime-input-buffer|. Default: 100

g:nvlime_contribs                                    *g:nvlime_contribs*
    A |list| of Swank contribs to load when initializing a Nvlime
    connection. Note that the names are case-sensitive. Please use
    only uppercase. Default: ["SWANK-ASDF", "SWANK-PACKAGE-FU",
    "SWANK-PRESENTATIONS", "SWANK-FANCY-INSPECTOR", "SWANK-C-P-C",
    "SWANK-ARGLISTS", "SWANK-REPL", "SWANK-FUZZY"]

    Some contrib modules will just work once they are loaded, but
    others may need specialized support on the client side. Nvlime
    elaborately supports these contribs by providing conforming client
    code:

        SWANK-ARGLISTS
            Show a fancy arglist. See |g:nvlime_enable_autodoc|.

        SWANK-FUZZY
            Enable fuzzy search in completions. See
            |nvlime-completions|.

        SWANK-MREPL
            Support for multiple REPLs. See |nvlime-mrepl|.

        SWANK-PRESENTATION-STREAMS
            Enable presentations on the standard output stream, and
            other similar streams, so that you can use
            |nvlime-mappings-repl-y| and similar mappings on printed
            objects.

        SWANK-PRESENTATIONS
            Turn evaluation results in the REPL into presentations,
            so that you can use |nvlime-mappings-repl-y| and similar
            mappings on the results.

        SWANK-REPL
            The default REPL implementation.

        SWANK-TRACE-DIALOG
            Interactively trace functions, and view the trace results.
            See |nvlime-trace-dialog|.

    Please consult the SLIME documentation for detailed descriptions
    for these modules.

    Alternatively, you can call |nvlime#plugin#SwankRequire()| to load
    contrib modules.

g:nvlime_user_contrib_initializers  *g:nvlime_user_contrib_initializers*
    A |dict| of |Funcref|s for initializing user contrib modules. The
    keys should be contrib module names (usually in uppercase). If
    your Swank contrib module needs special initialization, add an
    initializer function here. See autoload/nvlime/contrib.vim for
    examples. Default: {}

g:nvlime_enable_autodoc                        *g:nvlime_enable_autodoc*
    A boolean value specifying whether to enable the autodoc feature
    or not. If enabled, the current argument will be marked in the
    arglist, when typing parentheses-enclosed expressions. Default:
    v:false

g:nvlime_autodoc_max_level                  *g:nvlime_autodoc_max_level*
    A positive integer specifying how many levels of enclosing
    parentheses should Nvlime search for, when determining the arglist
    for the autodoc feature. Setting this to a smaller value may
    improve performance. Default: 5

g:nvlime_autodoc_max_lines                  *g:nvlime_autodoc_max_lines*
    A positive integer specifying how many lines to search, when
    determining the arglist for the autodoc feature. Setting this to a
    smaller value may improve performance. Default: 50

g:nvlime_main_win_pos                            *g:nvlime_main_win_pos*
    A string which allows to change the placement of the main windows
    (repl, sldb and compiler notes). Should be one of "top", "bottom",
    "left" or "right". Default: "right"

g:nvlime_scroll_up                                  *g:nvlime_scroll_up*
    A string representing key which scrolls Nvlime floating windows up.
    Default: "<C-p>"

g:nvlime_scroll_down                              *g:nvlime_scroll_down*
    A string representing key which scrolls Nvlime floating windows
    down. Default: "<C-n>"

g:nvlime_scroll_step                              *g:nvlime_scroll_step*
    A positive integer specifying how for many lines to scroll
    floating windows with one scroll key press. Default: 3

g:nvlime_enable_cmp                                *g:nvlime_enable_cmp*
    A boolean which enables autocompletion for `nvim-cmp` completion
    plugin.

g:nvlime_disable_mappings                    *g:nvlime_disable_mappings*
    A boolean which allows to disable all plugin mappings for all
    the windows. You should then provide some custom set of mappings.
    Default: false

g:nvlime_disable_global_mappings      *g:nvlime_disable_global_mappings*
    A boolean which allows to disable global mappings such as `q`,
    `<Esc>`, `<LocalLeader>ww`, `<F1>`, `<LocalLeader>?`, `<C-n>`
    and `<C-n>` that plugin maps for each of its windows.
    Default: false

g:nvlime_disable_input_mappings
g:nvlime_disable_xref_mappings
g:nvlime_disable_apropos_mappings
g:nvlime_disable_repl_mappings
g:nvlime_disable_sldb_mappings
g:nvlime_disable_mrepl_mappings
g:nvlime_disable_inspector_mappings
g:nvlime_disable_server_mappings
g:nvlime_disable_trace_mappings
g:nvlime_disable_notes_mappings
    A boolean which allows to disable mappings only for specific
    plugin window. Default: false


======================================================================
6. API                                               *nvlime-api-intro*

Nvlime's source code on the Neovim side is roughly organized into these
groups, and some of them are exported to be user-callable APIs:

    "nvlime#plugin#..." functions
        Top-level entry points to Nvlime features. Most of Nvlime's key
        mappings are mapped to these functions. Some of these
        functions are exported as APIs. See |nvlime-api-functions|.

    "nvlime#ui#..." functions
        UI-related code, which handles user input and special windows
        etc. Some of these functions are exported as APIs. See
        |nvlime-api-functions|.

    "nvlime#connection#..." functions
        Connection management. Internal use only.

    "nvlime#server#..." functions
        Server management. Internal use only.

    "nvlime#contrib#..." functions
        Support for Swank contrib modules. Internal use only.

    |nvlime-api.NvlimeConnection| object
        The low-level code encapsulating Nvlime's protocol and Swank
        messages. Most of the methods are exported as APIs.

Simply put, when you want to build something on top of Nvlime's
infrastructure, start from the top-level "nvlime#plugin#..." API
functions. Then, if you don't find what you want in the top-level API,
resort to the |nvlime-api.NvlimeConnection| object, and maybe the
"nvlime#ui#..." API functions.

All exported APIs are listed in |nvlime-api-functions| and
|nvlime-api.NvlimeConnection|. You can take a glance at the
documentation to see what exactly a certain group of functions can do.

Note that The API documentation is far from complete. When in doubt,
use the source. And please file an issue if you find any mistake in it
(see |nvlime-contrib|).

======================================================================
7. License                                             *nvlime-license*

This plugin is licensed under the terms of the MIT license. See
LICENSE.txt for details.

======================================================================
8. Bugs                                                   *nvlime-bugs*

* Nvlime is asynchronous. When the server takes too much time to
  process a request, you can still invoke other commands or input
  text, but the delayed result may cause some interference when it
  arrives.

* The Neovim interface may sometimes freeze until a command is issued
  (e.g. move the cursor).

Please file an issue on https://github.com/monkoose/nvlime/issues if
you find any other problem.

======================================================================
9. Contributing                                        *nvlime-contrib*

The source repo for Nvlime is hosted on GitHub:

    https://github.com/monkoose/nvlime

Please send pull requests if you have any suggestions for improving
Nvlime.

                                                         *nvlime-tests*
To make sure Nvlime works as intended on your platform, or to check if
something is broken after patching, it's recommended to run the tests.

To run the tests for the client side, make sure you have the Neovim
plugin properly installed, and then source the test runner script:

    nvim -S <nvlime repo>/vim/test/run_tests.vim

To run the tests for the server side, make sure "<nvlime repo>/lisp"
directory is in your "<quicklisp>/local-projects" directory (or make a
symlink), and then run the tests:

    sbcl --eval "(ql:quickload '(:nvlime-test :nvlime-sbcl-test))" \
         --eval "(test-with-coverage:main '(:nvlime :nvlime-sbcl) \"/path/to/coverage/output/\")" \
         --quit

The coverage output is only available for SBCL. If you're using
another implementation, or don't care about the coverage, just call
"(asdf:test-system ...)" directly. For example, using CCL:

    ccl --eval "(ql:quickload '(:nvlime-test))" \
        --eval "(asdf:test-system 'nvlime)" \
        --eval "(quit)"

The tests (both client-side and server-side) are organized in a rather
simple/naive way. Please refer to the existing test code if you want
to add new tests.
